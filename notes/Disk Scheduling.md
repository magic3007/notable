---
tags: [Notebooks/System/IO]
title: Disk Scheduling
created: '2020-01-06T01:37:46.740Z'
modified: '2020-02-18T15:03:23.257Z'
---

# Disk Scheduling

访盘时间 = 寻道时间(最慢, 主要是柱面之间的移动) + 旋转时间 + 传输时间

[磁盘调度的目的]

- 公平: 一个IO请求在有限时间内完成
- 高效: 减少机械运动带来的时间浪费

<u></u>

调度算法根据划分依据的不同分为<u>旋臂调度</u>(主要)和<u>旋转调度</u>.

| 磁盘调度算法             | Remark                                                       | 优点                   | 缺点                                                      |
| ------------------------ | ------------------------------------------------------------ | ---------------------- | --------------------------------------------------------- |
| 先来先服务(FCFS)         |                                                              | 简单，公平             | 效率不高;<br />磁头反复移动, 增加了服务时间, 对机械也不利 |
| 最短寻道时间优先         | 优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先   | 改善了磁盘平均服务时间 | 某些磁道较远的访问请求长期等待得不到服务                  |
| 扫描算法(SCAN, 电梯算法) | 当设备无访问请求时，磁头不动；<br />当有访问请求时，磁头按(任意)一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复 | 对距离和方向的折中权衡 |                                                           |
| 单向扫描调度算法C-SCAN   | 总是从0号柱面开始向里扫描<br/>按照各自所要访问的柱面位置的次序去选择访问<br/>者<br/>移动臂到达最后个一个柱面后，立即带动读写磁<br/>头快速返回到0号柱面<br/>返回时不为任何的等待访问者服务<br/>返回后可再次进行扫描 | 减少了新请求的最大延迟 |                                                           |
| N-step-SCAN策略 | 把磁盘请求队列分成长度为N的子队列，每一次用<br/>SCAN处理一个子队列<br/>在处理某一队列时，新请求必须添加到其他某个队<br/>列中<br/>如果在扫描的最后剩下的请求数小于N，则它们全<br/>都将在下一次扫描时处理<br/>对于比较大的N值， 其性能接近SCAN；当N＝1时，<br/>即FIFO | 克服磁头臂的黏性 | |
| FSCAN策略 | 使用两个子队列<br/>扫描开始时，所有请求都在一个队列中，而另一<br/>个队列为空<br/>扫描过程中，所有新到的请求都被放入另一个队<br/>列中<br/>对新请求的服务延迟到处理完所有老请求之后 | 克服磁头臂的黏性 | |
| 旋转调度算法 | 旋转调度：根据旋转时间延迟而不是寻道时间来决定执行次序的调度<br />主要思想是不同磁头的相同扇区可以同时访问<br />举个例子, 四个请求柱面号相同, (磁头号, 扇区号)分别为(4,1), [(1,5), (4,5)], (2,8) |  | |
